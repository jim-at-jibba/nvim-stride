This is the final, definitive System Design & Implementation Plan for stride.nvim (V1), now upgraded with Treesitter (AST) Intelligence.
You can pass this document directly to your AI coding agent. It contains the architecture, file structures, and exact Lua code required to build the plugin with structural awareness.
Project Specification: Stride.nvim (V1 + Treesitter)
Project Name: stride.nvim
Objective: Build a Neovim plugin that provides ultra-low latency, multi-line code predictions ("Ghost Text") using the Cerebras API.
Key Feature: Uses Treesitter AST to ensure context windows intelligently expand to capture full function definitions, preventing "blind" completions.
Backend: Cerebras API (Default: llama3.1-70b).
Dependencies: nvim-lua/plenary.nvim, nvim-treesitter/nvim-treesitter.
1. Core Architecture
 * Trigger: User stops typing for 300ms (Debounce).
 * Smart Context Capture:
   * Standard mode: Grab 60 lines up/down.
   * Treesitter Mode: Check if the top boundary cuts a function in half. If so, expand the window upwards to include the function signature. This ensures the LLM understands the arguments and return types of the current scope.
 * Inference: Send structured prompt to Cerebras.
 * Guard: Discard response if cursor moved (Race Condition Check).
 * Render: Display prediction via Extmarks (Virtual Text + Virtual Lines).
 * Action: User accepts with <Tab>.
2. Implementation Specification
Directory Structure
lua/
└── stride/
    ├── init.lua       # Setup, Autocommands, Keymaps
    ├── config.lua     # User Defaults
    ├── client.lua     # API Interaction
    ├── ui.lua         # Ghost Text Rendering
    └── utils.lua      # Context Extraction (Treesitter Logic)

Module 1: lua/stride/config.lua
local M = {}

M.defaults = {
    -- API Key (User must set env var)
    api_key = os.getenv("CEREBRAS_API_KEY"),
    
    -- Endpoint & Model
    endpoint = "https://api.cerebras.ai/v1/chat/completions",
    model = "llama3.1-70b", 
    
    -- UX Settings
    debounce_ms = 300,        -- Wait time
    accept_keymap = "<Tab>",  -- Accept key
    context_lines = 60,       -- Base window size
    
    -- Feature Flags
    use_treesitter = true,    -- Attempt to use AST for smarter context
    disabled_filetypes = {},  -- Filetypes to disable (e.g., {"markdown", "text"})
}

M.options = {}

function M.setup(opts)
    M.options = vim.tbl_deep_extend("force", M.defaults, opts or {})
end

return M

Module 2: lua/stride/utils.lua (The Brains)
Changes: Now includes expand_context_via_treesitter to intelligently resize the window.
local M = {}

M.timer = nil

-- Helper to find the start/end of the current function/block using Treesitter
local function expand_context_via_treesitter(buf, start_line, end_line)
    local ok, parser = pcall(vim.treesitter.get_parser, buf)
    if not ok or not parser then return start_line, end_line end

    local trees = parser:parse()
    if not trees or not trees[1] then return start_line, end_line end
    local root = trees[1]:root()

    -- Helper to check if node type is a structural block
    local function is_block_type(node_type)
        return node_type:match("function") or node_type:match("method") 
            or node_type:match("class") or node_type:match("impl")
    end

    -- 1. Check Top Boundary (start_line) - expand upward if we cut a block
    local top_node = root:named_descendant_for_range(start_line, 0, start_line, 0)
    
    while top_node do
        local node_type = top_node:type()
        if is_block_type(node_type) then
            local s_row, _, _, _ = top_node:range()
            if s_row < start_line then
                -- Limit expansion to avoid massive payloads
                if (start_line - s_row) <= 50 then
                    start_line = s_row
                end
            end
            break
        end
        top_node = top_node:parent()
    end

    -- 2. Check Bottom Boundary (end_line) - expand downward if we cut a block
    local bottom_node = root:named_descendant_for_range(end_line, 0, end_line, 0)
    
    while bottom_node do
        local node_type = bottom_node:type()
        if is_block_type(node_type) then
            local _, _, e_row, _ = bottom_node:range()
            if e_row > end_line then
                -- Limit expansion to avoid massive payloads
                if (e_row - end_line) <= 50 then
                    end_line = e_row
                end
            end
            break
        end
        bottom_node = bottom_node:parent()
    end

    return start_line, end_line
end

function M.get_context(base_context_lines)
    local buf = vim.api.nvim_get_current_buf()
    local cursor = vim.api.nvim_win_get_cursor(0)
    local row, col = cursor[1] - 1, cursor[2] -- 0-indexed
    local total_lines = vim.api.nvim_buf_line_count(buf)

    -- 1. Calculate Naive Boundaries (already handles edge cases via math.max/min)
    local start_line = math.max(0, row - base_context_lines)
    local end_line = math.min(total_lines, row + base_context_lines)

    -- 2. Smart Expansion (Treesitter)
    -- If available, expand boundaries to avoid cutting code blocks
    if require('stride.config').options.use_treesitter then
        start_line, end_line = expand_context_via_treesitter(buf, start_line, end_line)
    end

    -- 3. Extract Text
    local lines = vim.api.nvim_buf_get_lines(buf, start_line, end_line, false)
    
    -- 4. Split Prefix/Suffix at Cursor
    local cursor_line_idx = row - start_line + 1
    local current_line = lines[cursor_line_idx] or ""
    
    local prefix_lines = {}
    local suffix_lines = {}
    
    for i, line in ipairs(lines) do
        if i < cursor_line_idx then
            table.insert(prefix_lines, line)
        elseif i > cursor_line_idx then
            table.insert(suffix_lines, line)
        end
    end
    
    local prefix_part = string.sub(current_line, 1, col)
    local suffix_part = string.sub(current_line, col + 1)
    
    table.insert(prefix_lines, prefix_part)
    table.insert(suffix_lines, 1, suffix_part)
    
    return {
        prefix = table.concat(prefix_lines, "\n"),
        suffix = table.concat(suffix_lines, "\n"),
        row = row,
        col = col,
        buf = buf,
        filetype = vim.bo[buf].filetype
    }
end

function M.debounce(ms, callback)
    if M.timer then M.timer:stop(); M.timer:close() end
    M.timer = vim.loop.new_timer()
    M.timer:start(ms, 0, vim.schedule_wrap(callback))
end

return M

Module 3: lua/stride/ui.lua
local M = {}
local ns_id = vim.api.nvim_create_namespace("StrideGhost")

M.current_suggestion = nil 
M.current_buf = nil
M.extmark_id = nil

function M.clear()
    if M.extmark_id and M.current_buf then
        pcall(vim.api.nvim_buf_del_extmark, M.current_buf, ns_id, M.extmark_id)
    end
    M.extmark_id = nil
    M.current_suggestion = nil
    M.current_buf = nil
end

function M.render(text, row, col, buf)
    M.clear()
    if not text or text == "" then return end
    
    -- Verify buffer is still valid and current
    if not vim.api.nvim_buf_is_valid(buf) then return end
    if vim.api.nvim_get_current_buf() ~= buf then return end
    
    local lines = vim.split(text, "\n")
    
    -- Line 1: Inline after cursor
    local virt_text = { { lines[1], "Comment" } }
    
    -- Line 2+: Virtual lines below
    local virt_lines = {}
    if #lines > 1 then
        for i = 2, #lines do
            table.insert(virt_lines, { { lines[i], "Comment" } })
        end
    end
    
    local opts = {
        virt_text = virt_text,
        virt_text_pos = "inline",  -- Use inline to not obscure existing text
        hl_mode = "combine",
    }
    if #virt_lines > 0 then opts.virt_lines = virt_lines end
    
    M.extmark_id = vim.api.nvim_buf_set_extmark(buf, ns_id, row, col, opts)
    M.current_buf = buf
    M.current_suggestion = { text = text, row = row, col = col, lines = lines, buf = buf }
end

return M

Module 4: lua/stride/client.lua
local M = {}
local curl = require('plenary.curl')
local config = require('stride.config')

M.active_request_cursor = nil
M.active_job = nil  -- Track current request for cancellation

function M.cancel()
    if M.active_job then
        pcall(function() M.active_job:shutdown() end)
        M.active_job = nil
    end
end

local function do_fetch(context, callback, attempt)
    attempt = attempt or 1
    local max_retries = 3
    
    if not config.options.api_key then 
        vim.notify("stride.nvim: CEREBRAS_API_KEY not set", vim.log.levels.ERROR, { title = "stride.nvim" })
        return 
    end
    
    M.active_request_cursor = { context.row, context.col }
    local request_buf = context.buf  -- Track buffer for race condition check

    local messages = {
        {
            role = "system",
            content = "You are a precise code completion engine. Output ONLY the code that completes the current cursor position. Do not output markdown. Do not repeat the prefix. If no code is needed, output empty string."
        },
        {
            role = "user",
            content = string.format(
                "Filetype: %s\n[PREFIX]\n%s\n[SUFFIX]\n%s\n[TASK]\nComplete the code starting exactly at the end of PREFIX.",
                context.filetype, context.prefix, context.suffix
            )
        }
    }

    local payload = {
        model = config.options.model,
        messages = messages,
        temperature = 0.1,
        max_tokens = 256,
        stop = { "<|eot_id|>", "<|end_of_text|>" }
    }

    M.active_job = curl.post(config.options.endpoint, {
        body = vim.fn.json_encode(payload),
        headers = { ["Content-Type"] = "application/json", ["Authorization"] = "Bearer " .. config.options.api_key },
        callback = vim.schedule_wrap(function(out)
            M.active_job = nil
            
            -- Network/server error - retry
            if not out or out.status >= 500 then
                if attempt < max_retries then
                    vim.defer_fn(function()
                        do_fetch(context, callback, attempt + 1)
                    end, 100 * attempt)  -- Exponential backoff
                else
                    vim.notify("stride.nvim: API request failed after " .. max_retries .. " attempts", vim.log.levels.WARN, { title = "stride.nvim" })
                end
                return
            end
            
            -- Client error (4xx) - don't retry
            if out.status >= 400 then
                local msg = "stride.nvim: API error " .. out.status
                if out.status == 401 then msg = "stride.nvim: Invalid API key" end
                if out.status == 429 then msg = "stride.nvim: Rate limited" end
                vim.notify(msg, vim.log.levels.WARN, { title = "stride.nvim" })
                return
            end
            
            -- STALE CHECK: Did cursor move or buffer change?
            local cur_buf = vim.api.nvim_get_current_buf()
            if cur_buf ~= request_buf then return end
            
            local cur = vim.api.nvim_win_get_cursor(0)
            local r, c = cur[1] - 1, cur[2]
            if M.active_request_cursor[1] ~= r or M.active_request_cursor[2] ~= c then return end

            local ok, decoded = pcall(vim.fn.json_decode, out.body)
            if ok and decoded.choices then
                callback(decoded.choices[1].message.content, r, c, request_buf)
            end
        end)
    })
end

function M.fetch_prediction(context, callback)
    M.cancel()  -- Cancel any in-flight request
    do_fetch(context, callback)
end

return M

Module 5: lua/stride/init.lua
local M = {}
local config = require('stride.config')
local utils = require('stride.utils')
local client = require('stride.client')
local ui = require('stride.ui')

local function is_disabled()
    local ft = vim.bo.filetype
    for _, disabled_ft in ipairs(config.options.disabled_filetypes or {}) do
        if ft == disabled_ft then return true end
    end
    return false
end

function M.setup(opts)
    if not pcall(require, "plenary") then error("stride.nvim requires plenary.nvim") end
    -- Optional warning for Treesitter
    if opts and opts.use_treesitter and not pcall(require, "nvim-treesitter") then
        vim.notify("stride.nvim: Treesitter enabled but not found. Falling back to text mode.", vim.log.levels.WARN)
    end

    config.setup(opts)
    local augroup = vim.api.nvim_create_augroup("StrideGroup", { clear = true })

    vim.api.nvim_create_autocmd("TextChangedI", {
        group = augroup,
        callback = function()
            if is_disabled() then return end
            ui.clear()
            client.cancel()  -- Cancel in-flight requests
            utils.debounce(config.options.debounce_ms, function()
                if is_disabled() then return end
                local ctx = utils.get_context(config.options.context_lines)
                client.fetch_prediction(ctx, ui.render)
            end)
        end
    })

    -- Clear on cursor move, mode change, or leaving insert
    vim.api.nvim_create_autocmd({"CursorMovedI", "InsertLeave", "ModeChanged"}, {
        group = augroup, 
        callback = function() 
            ui.clear() 
            client.cancel()
        end
    })

    -- Tab keymap: accept suggestion or fallback to normal Tab
    vim.keymap.set('i', config.options.accept_keymap, function()
        return M.accept()
    end, { expr = true, silent = true })
end

function M.accept()
    local s = ui.current_suggestion
    if s and s.text and s.text ~= "" then
        local buf = s.buf or vim.api.nvim_get_current_buf()
        local r, c = s.row, s.col
        vim.api.nvim_buf_set_text(buf, r, c, r, c, { s.lines[1] })
        if #s.lines > 1 then
            local extra = {unpack(s.lines, 2)}
            vim.api.nvim_buf_set_lines(buf, r + 1, r + 1, false, extra)
        end
        local last_len = #s.lines[#s.lines]
        local tr = r + #s.lines - 1
        local tc = (tr == r) and (c + last_len) or last_len
        vim.api.nvim_win_set_cursor(0, { tr + 1, tc })
        ui.clear()
        return ""
    else
        -- Fallback to normal Tab behavior
        return vim.api.nvim_replace_termcodes("<Tab>", true, false, true)
    end
end

return M

3. Deployment Instructions for the Agent
 * Environment Check: Verify nvim-treesitter is installed and a parser is active for the language being edited (e.g., :TSInstall lua).
 * API Check: Ensure CEREBRAS_API_KEY is present.
 * Validation:
   * Open a Lua file.
   * Write a function start: local function test(a, b).
   * Pause.
   * Verify the AI completes it based on the arguments.
   * Treesitter Test: Write a function above the cursor but outside the 60-line default window. Check if utils.lua successfully expanded the context to include it (debug print recommended in utils.lua for this test).
